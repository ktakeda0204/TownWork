<!DOCTYPE html>
<html>
  <head>
    <title>ROOTメモ</title>
    <meta charset="utf-8" />
  </head>

  
<body>
    <h1>Linuxメモ</h1>
    <h2>コマ数等の確認</h2>
    <h3>CPU</h3>
    <p>
    CPUの中に中央処理ユニットがある
    <ul>
    <li>このユニットがいくつあるか→「コア数」</li>
    <li>1つのコア内で、同時に複数の命令列を実行するための機能→「スレッド数」</li>
    </ul>
    </p>

    <h3>物理CPU数</h3>
    <p>grep physical.id /proc/cpuinfo | sort -u | wc -l <br>
    出力された数字が物理的なCPUの数を表している。</p>
    
    <h3>CPU(=プロセッサ)毎のコア数</h3>
    <p>grep cpu.cores /proc/cpuinfo | sort -u</p>

    <h3>論理CPU(=論理プロセッサ)の数</h3>
    <p>grep processor /proc/cpuinfo | wc -l <br>
    Hyper threading(1コアで2スレッドをサポート)に対応していれば、実際のコア数はn個であれば、論理CPUの数はその2倍の2×n個になる
    </p>

    <h2>プロセスとは</h2>
    <p>プロセスとは、プログラム以外に割り当てられたメモリ領域、接続中のソケット、読み書き中のファイル等I/O装置の集合体
    これらをOSが管理し、実際にCPUを使って動かすプロセスを適宜切り替えて、並行して動かしていく。
    プログラムは実行する前はストレージに保管されている。
    実行するタイミングでメモリーに読み出される。
    最初から実行され、プログラムが終了するとプロセスは消失する。
    親プロセスと子プロセスは基本的にデータの共有は行わない。
    作成に時間がかかる。
    </p>
    <p>
    initプロセス
    Linuxは起動後、initiプロセスを起動する
    このプロセスが全ての親
    ユーザーがログインするとログインシェルプロセスが生成される
    </p>

    <p>
    OSは、プログラムに適切なコンピュータ資源、メモリやCPU時間などを割り振る
    プロセスは終了するとメモリ領域を開放する
    マルチプロセスはOSが、順次切り替えてプロセスを実行しているに過ぎない
    pstree：プロセスの家系図
    </p>
    
    <h2>パフォーマンスモニタリング</h2>
    <p>
    vmstat   <br>
    </p>

    <h2>仮想メモリ</h2>
    <p>
    各プログラムが実メモリ（物理メモリ）を直接触るしか実装方法が無いようなシステムでは、拡張性が貧弱なシステムとなる。
    そもそもプログラムからすれば実メモリが一体どれだけ実装されているPC上で動作することになるか分からないからだ。
    そこで仮想メモリという概念が必要になる。この仮想メモリを導入することで、物理メモリの配置を気にしなくよくなり、
    物理メモリを扱うのはカーネルとデバイスドライバだけとすれば良い。
    仮想メモリと実メモリの対応付をカーネルに任せて、ユーザープログラムはユーザープログラムの仕事だけに専念すればいい。
    </p>
    
    <h3>スワップイン</h3>
    <p>一度ディスク(swap領域)に書き出した内容を、をカーネルがロードして物理メモリに展開すること。
    </p>
    
    <h3>スワップアウト</h3>
    物理メモリの空きがなくなった場合、使用頻度の低いと思われるページをディスク(swap領域)に書き込んで、メモリを解放する事
    <p>

    これらのスワップイン・アウトはカーネルが勝手にやってくれる。
    しかし、これらの動作はI/O処理速度の遅いディスクとのやり取りをしているということなので、
    スワップイン・アウトが頻繁に起きてしまうとユーザーとしては「処理が遅いな」と感じてしまう事になる。

    </p>


  </body>
</html>

