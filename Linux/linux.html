<!DOCTYPE html>
<html>
  <head>
    <title>ROOTメモ</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../CSS/style.css">

  </head>

  
<body>
    <h1>Linuxメモ</h1>
    <ul>
    <li><a href="#ram">RAM</a></li>
    <li><a href="#core">コア数等の確認</a></li>
    <li><a href="#process">プロセスとは</a></li>
    <li><a href="#virtual">仮想メモリ</a></li>
    <li><a href="#network_interface">Linuxのネットワークインターフェース</a></li>
    <li><a href="#init_script">起動スクリプト</a></li>
    <li><a href="#cache">キャッシュにつて</a></li>
    <li><a href="#memory_space">メモリ空間</a></li>
    </ul>
    
    <h2 id="ram">RAM</h2>
    ランダムアクセスメモリの事で、CPU（プロセッサ）が何らかの処理を行う時に使用する領域で、メインメモリ、物理メモリとも言う。
    Linuxでは、この物理メモリ上のアドレス空間である物理メモリをそのままユーザープロセスに使わせるのではなく、
    その物理メモリと対応付けられた仮想メモリ空間を使用する。
    こうする事で、ユーザープロセスは実際の物理メモリの構造を知っていなくても開発を進めることが出来る。
    
    <h2 id="core">コア数等の確認</h2>
    <h3>CPU</h3>
    <p>
    CPUの中に中央処理ユニットがある
    <ul>
    <li>このユニットがいくつあるか→「コア数」</li>
    <li>1つのコア内で、同時に複数の命令列を実行するための機能→「スレッド数」</li>
    </ul>
    </p>

    <h3>物理CPU数</h3>
    <pre><code>
      grep physical.id /proc/cpuinfo | sort -u | wc -l 
    </code></pre>
    出力された数字が物理的なCPUの数を表している。</p>
    
    <h3>CPU(=プロセッサ)毎のコア数</h3>
    <pre><code>
     grep cpu.cores /proc/cpuinfo | sort -u
     </code></pre>

    <h3>論理CPU(=論理プロセッサ)の数</h3>
    <pre><code>
    grep processor /proc/cpuinfo | wc -l 
    </code></pre>
    Hyper threading(1コアで2スレッドをサポート)に対応していれば、実際のコア数はn個であれば、論理CPUの数はその2倍の2×n個になる
    </p>

    <h2 id="process">プロセスとは</h2>
    <p>プロセスとは、プログラム以外に割り当てられたメモリ領域、接続中のソケット、読み書き中のファイル等I/O装置の集合体
    これらをOSが管理し、実際にCPUを使って動かすプロセスを適宜切り替えて、並行して動かしていく。
    プログラムは実行する前はストレージに保管されている。
    実行するタイミングでメモリーに読み出される。
    最初から実行され、プログラムが終了するとプロセスは消失する。
    親プロセスと子プロセスは基本的にデータの共有は行わない。
    作成に時間がかかる。
    </p>
    <p>
    initプロセス
    Linuxは起動後、initiプロセスを起動する
    このプロセスが全ての親
    ユーザーがログインするとログインシェルプロセスが生成される
    </p>

    <p>
    OSは、プログラムに適切なコンピュータ資源、メモリやCPU時間などを割り振る
    プロセスは終了するとメモリ領域を開放する
    マルチプロセスはOSが、順次切り替えてプロセスを実行しているに過ぎない
    pstree：プロセスの家系図
    </p>
    

    <h2 id="virtual memory">仮想メモリ</h2>
    <p>
    各プログラムが実メモリ（物理メモリ）を直接触るしか実装方法が無いようなシステムでは、拡張性が貧弱なシステムとなる。
    そもそもプログラムからすれば実メモリが一体どれだけ実装されているPC上で動作することになるか分からないからだ。
    そこで仮想メモリという概念が必要になる。この仮想メモリを導入することで、物理メモリの配置を気にしなくよくなり、
    物理メモリを扱うのはカーネルとデバイスドライバだけとすれば良い。
    仮想メモリと実メモリの対応付をカーネルに任せて、ユーザープログラムはユーザープログラムの仕事だけに専念すればいい。
    </p>
    
    <h3>スワップイン</h3>
    <p>一度ディスク(swap領域)に書き出した内容を、をカーネルがロードして物理メモリに展開すること。
    </p>
    
    <h3>スワップアウト</h3>
    物理メモリの空きがなくなった場合、使用頻度の低いと思われるページをディスク(swap領域)に書き込んで、メモリを解放する事
    <p>

    これらのスワップイン・アウトはカーネルが勝手にやってくれる。
    しかし、これらの動作はI/O処理速度の遅いディスクとのやり取りをしているということなので、
    スワップイン・アウトが頻繁に起きてしまうとユーザーとしては「処理が遅いな」と感じてしまう事になる。

    </p>
    
    <h2 id="network_interface">Linux　ネットワークインターフェース</h2>
    言葉・知識の整理
    <ul>
    <li>eth</li>
      <ul>
        <li>実装されているネットワークカードは、何も指定しなければ順にeth0、eth1、、、と名前が付けられる。</li>
      </ul>
    <li>/etc/hosts</li>
      <ul>
        <li>ネットワークインターフェースの設定が書き込まれているファイル。</li>
      </ul>
    <li>ifconfig</li>
      <ul>
        <li>ネットワーク・インタフェースに割り当てられているIPアドレスやネットマスクを確認できる。
            オプションを付けずに打つと、現在起動しているネットワークインターフェースを表示できる。
        </li>
      </ul>
    <li>service network status</li>
      <ul>
      <li>ネットワークサービスのステータスを確認できる。</li>
      </ul>
    <li>ethtool インターフェース名</li>
      <ul>
       <li>指定したインターフェース名のNICがどの通信速度に対応しているかを見ることが出来る。</li>
       </ul>
    </ul>


    <h2 id="init_script">起動スクリプト</h2>
    デバイスドライバを起動するためのスクリプト。/etc/init.d以下に配置して置くと起動時に読み込まれる。
    start、stop、statusの引数を取れる様にしておくと便利で、特にstatusでカーネルモジュールがロードされていなければ
    exitコードを例えば1を返すようにしておくと、「カーネルモジュールがロードされていない！」と分かって便利。

    <h2 id="RAM">RAMディスク</h2>
    RAMディスクとは、メインメモリーの一部を確保し、ディスク装置であるかの様に利用できるメモリー領域の事。
    高速なアクセスが可能であるが、大容量のRAMディスクの確保は難しい。
    <ul>
    <li>initrd</li>
    <li>/dev/shm</li>
    <li>/dev/ramdisk</li>
    </ul>
    
    <h2 id="cache">キャッシュについて</h2>
    HDDやSDDのブロックデバイスへのアクセス効率をよくするには、高速にアクセスできるメモリ上にで０たを一時保管して、低速なブロックデバイスへの
    アクセス回数を減らせばよい。この用に、データを一時保管する為に使うメモリをキャッシュメモリという。
    <ul>
    <li>CPU内蔵キャッシュ</li>
    <li>記憶装置内蔵キャッシュ</li>
    </ul>
    ディスク書き込みをユーザーアプリケーションが行う時、仮想ファイルシステムVFSが役に立つ。
    VFSにはブロックデバイスとのアクセス効率化を図るキャッシュ機構が組み込まれている。
    
    <h3>write()</h3>
    アプリケーションはデータを書き込んだタイミングで書き込みが終了するが、これは実際にブロックデバイスへ書き込みが終了したタイミングでは無い。
    アプリケーションは仮想ファイルシステムのキャッシュメモリにデータを書き込んだ時にwrite()が成功した、と伝えられる。
    そしてカーネルがタイミングを見計らって、キャッシュ上からブロックデバイスへとデータを移してくれる。
    このキャッシュは2段構造になっている。
    <ul>
    <li>ページキャッシュ</li>
    <ul><li>ユーザーアプリケーションからのデータを一時的に保存する所の事。ページキャッシュへデータを置いた時にwrtite()のtrueが返ってくる。</li></ul>
    <li>バッファャッシュ</li>
    <ul><li>ブロックデバイスにアクセスするときに経由されるキャッシュ。実際にHDDに書き込まれるまではこのバッファキャッシュに保存される。</li></ul>
    </ul>
    
    <h3>read()</h3>
    ブロックデバイスからデータを読み出す時は直接HDDを読みに行くのではなく、まずページキャッシュ→バッファキャッシュ→HDD内キャッシュへとアクセスする。
    この時に欲しい情報がキャッシュ内に残っていて、キャッシュからデータを読み出せた時「キャッシュにヒットする」と呼んだりする。
    キャッシュにヒット出来れば高速なアクセスが成功するが、もしキャッシュ上に欲しいデータが無ければHDDへディスクアクセスを行うことになる。
    そうなると、処理が非常に遅くなってしまう。

    <h2 id="tmpfs">tmpfsについて</h2>
    <p>
    メインメモリ（物理メモリ）上に一定量のブロックファイルを作成して、それを任意のディレクトリにマウントしRAMディスクとして使用できる機能のこと。
    マウントしただけではメインメモリの容量は変わらないが、マウントされたディレクトリにデータを置いた時にメインメモリが削られる。
    </p>
    <p>
    dfコマンドで見たりすると、tmpfsがどこにマウントされているかが分かる。一般的には/dev/shmにマウントされている事が多い。
    </p>
    
    <h2 id="memory_space">メモリ空間</h2>
    <p>32bitのプロセッサではメモリ空間は0x00000000~0xFFFFFFFFまでの合計4Gバイトで、Linuxでは前半をユーザー空間、後半をカーネル空間に分ける。
    これらのアドレス空間は仮想化されているもので、実際の物理メモリ上のアドレスとは異なる。
    仮想メモリーと物理メモリーへのマッピング（対応付け）はハードウェア上に実装されているページテーブルで行われる。
    このページテーブルの構成はカーネルが行う。
    </p>
    また、あまり使用されないページはアクセス速度の遅いディスク


  </body>
</html>

